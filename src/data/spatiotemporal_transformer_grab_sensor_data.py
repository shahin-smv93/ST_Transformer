# -*- coding: utf-8 -*-
"""Spatiotemporal_transformer_grab_sensor_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OyKD-SUiwfm2erZjp-k1EdJ-D-Px_-Q4


This script is written for a specific dataset and project (reconstructing 2D turbulent 
sparse, limited sensor data).
"""

import numpy as np
import os
import glob

def load_data(path):
    DATASET_PATH = path
    dataset = glob.glob(DATASET_PATH+"/*.npy")
    all_frames = []
    for file in sorted(dataset):
        x = np.load(file)
        all_frames.append(x)
    all_frames = np.array(all_frames)
    return all_frames[:, :, :60, :]


def scaling_data(data):
  data_ch1 = data[:, :, :, 0] - np.mean(data[:, :, :, 0])
  data_ch2 = data[:, :, :, 1] - np.mean(data[:, :, :, 1])

  scaled_ch1 = (data_ch1 - np.min(data_ch1)) / (np.max(data_ch1) - np.min(data_ch1))
  scaled_ch2 = (data_ch2 - np.min(data_ch2)) / (np.max(data_ch2) - np.min(data_ch2))

  dataset = np.zeros((data.shape[0], data.shape[1], data.shape[2], data.shape[3]))
  dataset[:, :, :, 0] = scaled_ch1
  dataset[:, :, :, 1] = scaled_ch2

  return dataset

def extract_datapoints(dataset, x_indices: list, y_indices: list, separate_channels: bool = True):
  if not isinstance(x_indices, list) or not isinstance(y_indices, list):
    raise ValueError("x_indices and y_indices must be lists")

  # convert lists to numpy arrays
  x_indices = np.array(x_indices)
  y_indices = np.array(y_indices)

  if x_indices.shape[0] != y_indices.shape[0]:
    raise ValueError("x_indices and y_indices must have the same length")

  xx, yy = np.meshgrid(x_indices, y_indices)
  indices = np.vstack([xx.ravel(), yy.ravel()]).T

  num_samples = dataset.shape[0]
  num_points = indices.shape[0]
  extracted_data = np.zeros((num_samples, num_points, 2))

  for i, (x, y) in enumerate(indices):
    extracted_data[:, i, :] = dataset[:, x, y, :]

  if separate_channels:
    extracted_data_one = extracted_data[:, :, 0]
    extracted_data_two = extracted_data[:, :, 1]
    return extracted_data_one, extracted_data_two
  else:
    extracted_data = np.reshape(extracted_data, (extracted_data.shape[0], extracted_data.shape[1] * extracted_data.shape[2]))
    return extracted_data
